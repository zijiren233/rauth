package k8s

import (
	"context"
	"errors"
	"fmt"
	"os"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

const (
	// DefaultSecretName is the fixed secret name generated by controller in each namespace
	DefaultSecretName = "devbox-registry"
)

// ClientInterface defines the interface for Kubernetes client operations
type ClientInterface interface {
	GetNamespaceCredentials(ctx context.Context, namespace string) (*RegistryCredentials, error)
	NamespaceExists(ctx context.Context, namespace string) (bool, error)
}

// RegistryCredentials holds the username and password for registry authentication
type RegistryCredentials struct {
	Username string
	Password string
}

// Client wraps kubernetes clientset
type Client struct {
	clientset  kubernetes.Interface
	secretName string
}

// NewClient creates a new kubernetes client
func NewClient(secretName string) (*Client, error) {
	var (
		config *rest.Config
		err    error
	)

	// Try in-cluster config first
	config, err = rest.InClusterConfig()
	if err != nil {
		// Fall back to kubeconfig for local development
		kubeconfig := os.Getenv("KUBECONFIG")
		if kubeconfig == "" {
			kubeconfig = os.Getenv("HOME") + "/.kube/config"
		}

		config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
		if err != nil {
			return nil, fmt.Errorf("failed to create kubernetes config: %w", err)
		}
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, fmt.Errorf("failed to create kubernetes clientset: %w", err)
	}

	if secretName == "" {
		secretName = DefaultSecretName
	}

	return &Client{
		clientset:  clientset,
		secretName: secretName,
	}, nil
}

// NewClientWithInterface creates a client with a provided kubernetes interface (for testing)
func NewClientWithInterface(clientset kubernetes.Interface, secretName string) *Client {
	if secretName == "" {
		secretName = DefaultSecretName
	}

	return &Client{
		clientset:  clientset,
		secretName: secretName,
	}
}

// GetNamespaceCredentials retrieves registry credentials from the secret in specified namespace
func (c *Client) GetNamespaceCredentials(
	ctx context.Context,
	namespace string,
) (*RegistryCredentials, error) {
	secret, err := c.clientset.CoreV1().
		Secrets(namespace).
		Get(ctx, c.secretName, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf(
			"failed to get secret %s in namespace %s: %w",
			c.secretName,
			namespace,
			err,
		)
	}

	return ExtractCredentials(secret)
}

// ExtractCredentials extracts username and password from secret
func ExtractCredentials(secret *corev1.Secret) (*RegistryCredentials, error) {
	username, ok := secret.Data["username"]
	if !ok {
		return nil, errors.New("secret does not contain 'username' key")
	}

	password, ok := secret.Data["password"]
	if !ok {
		return nil, errors.New("secret does not contain 'password' key")
	}

	return &RegistryCredentials{
		Username: string(username),
		Password: string(password),
	}, nil
}

// NamespaceExists checks if a namespace exists
func (c *Client) NamespaceExists(ctx context.Context, namespace string) (bool, error) {
	_, err := c.clientset.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
	if err != nil {
		return false, nil
	}

	return true, nil
}

// GetSecretName returns the configured secret name
func (c *Client) GetSecretName() string {
	return c.secretName
}
